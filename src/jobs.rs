use crate::output::Output;
use crate::nodes::Node;
use nix::unistd::Pid;
use std::cell::RefCell;
use std::rc::Rc;

enum JobStates {
    Running,
    Stopped,
    Done,
}

pub struct ProcessStatus {
    pid: Pid,       // process id
    status: i32,    // last process status from wait()
    cmd: String,    // text of command being run
}

/*
 * A job structure contains information about a job.  A job is either a
 * single process or a set of processes contained in a pipeline.  In the
 * latter case, pidlist will be non-NULL, and will point to a -1 terminated
 * array of pids.
 */
pub struct Job {
    ps0: ProcessStatus,         // status of process 
    ps: Option<ProcessStatus>,  // status or processes when more than one
    stop_status: i32,           // status of a stopped job
    num_procs: u16,             // number of processes
    state: u8,
    sigint: bool,               // job was killed by SIGINT
    jobctl: bool,               // job running under job control
    waited: bool,               // true if this entry has been waited for
    used: bool,                 // true if this entry is in used
    changed: bool,              // true if status has changed
}

pub const SHOW_PGID: i32 = 0x01;        // only show pgid - for jobs -p
pub const SHOW_PID: i32 = 0x04;         // include process pid
pub const SHOW_CHANGED: i32 = 0x08;     // only jobs whose state has changed

pub static mut JOBCTL: bool = false;    // true if doing job control
pub static mut JOB_WARNING: i32 = 0;




/*
 * Return a new job structure.
 * Called with interrupts off.
 */
pub fn make_job(node: Box<Option<Node>>, num_procs:i32) -> Rc<RefCell<Job>> {
    unimplemented!()
}
/*
 * Print a list of jobs.  If "change" is nonzero, only print jobs whose
 * statuses have changed since the last call to showjobs.
 */
pub fn show_jobs(out: Output, mode: i32) {


}

pub fn stopped_jobs() -> i32 {
    
    0
}

pub fn fork_shell(job: Rc<RefCell<Job>>, node: Box<Option<Node>>, mode: i32) -> Pid {
    unimplemented!()
}


/*
 * Wait for job to finish.
 *
 * Under job control we have the problem that while a child process is
 * running interrupts generated by the user are sent to the child but not
 * to the shell.  This means that an infinite loop started by an inter-
 * active user may be hard to kill.  With job control turned off, an
 * interactive user may place an interactive program inside a loop.  If
 * the interactive program catches interrupts, the user doesn't want
 * these interrupts to also abort the loop.  The approach we take here
 * is to have the shell ignore interrupt signals while waiting for a
 * forground process to terminate, and then send itself an interrupt
 * signal if the child process was terminated by an interrupt signal.
 * Unfortunately, some programs want to do a bit of cleanup and then
 * exit on interrupt; unless these processes terminate themselves by
 * sending a signal to themselves (instead of calling exit) they will
 * confuse this approach.
 *
 * Called with interrupts off.
 */

pub fn wait_for_job(job: Job) -> i32 {
    unimplemented!()
}
